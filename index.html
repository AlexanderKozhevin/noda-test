<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>colorize.cc OS — XR Mind Map</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; background:#050510; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud {
      position: fixed; left: 14px; bottom: 14px; z-index: 10;
      width: min(620px, calc(100vw - 28px));
      color: #d7f7ff;
      background: rgba(5, 10, 20, .58);
      border: 1px solid rgba(120, 220, 255, .22);
      border-radius: 14px;
      padding: 12px 12px 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
      user-select: none;
    }
    #hud h3 { margin: 0 0 8px; font-size: 14px; letter-spacing:.4px; color:#8ff0ff; }
    #hud small { opacity:.9; display:block; margin-top:6px; line-height:1.25; }
    #jsonBox {
      display:none;
      margin-top:10px;
      width:100%;
      height:200px;
      border-radius: 12px;
      border: 1px solid rgba(120, 220, 255, .22);
      background: rgba(0,0,0,.35);
      color:#e9fbff;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      outline:none;
      resize: vertical;
    }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap: wrap; }
    .pill {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(120, 220, 255, .22);
      background: rgba(0,0,0,.22);
      font-size: 12px;
      opacity: .95;
    }
    button {
      border-radius: 12px;
      border: 1px solid rgba(120, 220, 255, .25);
      background: rgba(0, 200, 255, .10);
      color:#c9fbff;
      padding: 10px 12px;
      cursor: pointer;
    }
    button:hover { background: rgba(0, 200, 255, .16); }
    button:active { transform: translateY(1px); }
  </style>
</head>

<body>
  <!-- Desktop helper (auto-hides in VR) -->
  <div id="hud">
    <h3>colorize.cc OS — XR Mind Map</h3>
    <div class="row">
      <div class="pill">Left stick: move • Right stick: turn</div>
      <div class="pill">Trigger: select • Grip: move node • A: add • B: delete • Y: link • X: rename</div>
      <div class="pill">Hold BOTH grips: move/rotate/zoom whole graph</div>
      <div style="display:flex; gap:8px;">
        <button id="toggleJson">JSON</button>
        <button id="applyJson">Apply</button>
        <button id="exportJson">Export</button>
      </div>
    </div>
    <textarea id="jsonBox" spellcheck="false"></textarea>
    <small>Tip: For best feel, keep movement rig-relative (this build). Turning your head won't invert movement.</small>
  </div>

  <!-- JSON definition -->
  <script type="application/json" id="mindmap-json">
  {
    "nodes": [
      { "id": "core", "label": "Core", "pos": [0, 1.6, -2.8], "color": "#00F0FF", "size": 0.18 },
      { "id": "ux",   "label": "UX",   "pos": [-1.4, 1.55, -3.6], "color": "#7CFF6B", "size": 0.16 },
      { "id": "ml",   "label": "ML",   "pos": [1.6, 1.75, -3.7], "color": "#FF4FD8", "size": 0.16 },
      { "id": "api",  "label": "API",  "pos": [0.0, 1.15, -4.6], "color": "#FFD24D", "size": 0.15 }
    ],
    "links": [
      { "from": "core", "to": "ux",  "color": "#00F0FF", "thickness": 0.012 },
      { "from": "core", "to": "ml",  "color": "#00F0FF", "thickness": 0.012 },
      { "from": "core", "to": "api", "color": "#00F0FF", "thickness": 0.012 }
    ]
  }
  </script>

  <a-scene
    id="scene"
    background="color: #050510"
    renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true;"
    fog="type: exponential; color: #050510; density: 0.018"
    xr-mode-ui="enabled: true">

    <!-- Lights -->
    <a-entity light="type: ambient; intensity: 0.28; color: #7fdcff"></a-entity>
    <a-entity light="type: directional; intensity: 0.62; color: #ffffff" position="-1 3 1"></a-entity>
    <a-entity light="type: point; intensity: 0.35; distance: 20; color: #00F0FF" position="0 4 -4"></a-entity>

    <!-- Big rectangular room -->
    <a-entity id="room">
      <a-plane id="floor" class="surface hitSurface"
        rotation="-90 0 0" width="60" height="60"
        material="shader: standard; color: #07070d; metalness: 0.15; roughness: 0.9"
        procedural-grid="size: 60; lines: 90; majorEvery: 6; minorColor: rgba(0,240,255,0.06); majorColor: rgba(0,240,255,0.15)">
      </a-plane>

      <!-- Back wall -->
      <a-plane class="surface hitSurface"
        position="0 4 -20" width="60" height="12"
        material="shader: standard; color:#060612; metalness:0.28; roughness:0.7; emissive:#020218; emissiveIntensity:0.55">
      </a-plane>

      <!-- Side walls -->
      <a-plane class="surface hitSurface"
        position="-30 4 0" rotation="0 90 0" width="40" height="12"
        material="shader: standard; color:#060612; metalness:0.20; roughness:0.75; emissive:#010115; emissiveIntensity:0.35; opacity:0.95; transparent:true">
      </a-plane>

      <a-plane class="surface hitSurface"
        position="30 4 0" rotation="0 -90 0" width="40" height="12"
        material="shader: standard; color:#060612; metalness:0.20; roughness:0.75; emissive:#010115; emissiveIntensity:0.35; opacity:0.95; transparent:true">
      </a-plane>

      <!-- Neon title block -->
      <a-entity position="0 6.3 -19.4">
        <a-text value="colorize.cc OS" align="center" width="10" color="#8ff0ff" opacity="0.98"></a-text>
        <a-plane position="0 -0.15 -0.02" width="9.2" height="1.3"
          material="shader: standard; color:#00131a; emissive:#00F0FF; emissiveIntensity:0.65; opacity:0.30; transparent:true; roughness:1.0; metalness:0.0">
        </a-plane>
        <a-entity neon-frame="w: 13.5; h: 3.6; color: #00F0FF" position="0 -0.2 0"></a-entity>
      </a-entity>
    </a-entity>

    <!-- Workspace (entire graph lives here; we scale/rotate/move THIS) -->
    <a-entity id="workspace" position="0 0 0" rotation="0 0 0" scale="1 1 1">
      <a-entity id="mindmapRoot" mindmap="src: #mindmap-json;"></a-entity>
    </a-entity>

    <!-- Selection ring -->
    <a-entity id="selectionRing" visible="false" selection-ring></a-entity>

    <!-- VR Keyboard -->
    <a-entity id="vrKeyboard" visible="false" vr-keyboard></a-entity>

    <!-- Player rig -->
    <a-entity id="rig" position="0 0 10"
      locomotion-rig="leftHand: #leftHand; rightHand: #rightHand; moveSpeed: 2.6; turnSpeed: 78; deadzone: 0.18;"
      mind-controls="leftHand: #leftHand; rightHand: #rightHand; workspace: #workspace; root: #mindmapRoot; ring: #selectionRing; keyboard: #vrKeyboard;">

      <a-entity id="camera"
        camera
        position="0 1.6 0"
        look-controls="pointerLockEnabled: false"
        wasd-controls="acceleration: 26">
      </a-entity>

      <a-entity id="leftHand"
        oculus-touch-controls="hand: left"
        raycaster="objects: .hitNode, .hitUI, .hitSurface; far: 35; interval: 0"
        line="color: #00F0FF; opacity: 0.55">
      </a-entity>

      <a-entity id="rightHand"
        oculus-touch-controls="hand: right"
        raycaster="objects: .hitNode, .hitUI, .hitSurface; far: 35; interval: 0"
        line="color: #FF4FD8; opacity: 0.55">
      </a-entity>
    </a-entity>

    <script>
      // ----------------------------
      // Helpers
      // ----------------------------
      const clamp = (v,a,b)=> Math.min(b, Math.max(a, v));
      const rand = (a,b)=> a + Math.random()*(b-a);
      const niceId = (prefix="n")=> prefix + Math.random().toString(16).slice(2, 9);

      function haptic(handEl, strength=0.2, dur=35){
        const ctrl = handEl?.components?.['oculus-touch-controls']?.controller;
        const h = ctrl?.gamepad?.hapticActuators?.[0];
        if (!h) return;
        try { h.pulse(strength, dur); } catch {}
      }

      function getWorldPos(el, out=new THREE.Vector3()){
        el.object3D.getWorldPosition(out);
        return out;
      }

      // ----------------------------
      // Hide HUD in VR
      // ----------------------------
      (function(){
        const hud = document.getElementById('hud');
        const scene = document.getElementById('scene');
        scene.addEventListener('enter-vr', () => { hud.style.display = 'none'; });
        scene.addEventListener('exit-vr',  () => { hud.style.display = 'block'; });
      })();

      // ----------------------------
      // Floor grid texture
      // ----------------------------
      AFRAME.registerComponent('procedural-grid', {
        schema: {
          size: { type: 'number', default: 40 },
          lines: { type: 'number', default: 40 },
          majorEvery: { type: 'number', default: 5 },
          minorColor: { type: 'string', default: 'rgba(0,240,255,0.08)' },
          majorColor: { type: 'string', default: 'rgba(0,240,255,0.18)' }
        },
        init() {
          const canvas = document.createElement('canvas');
          canvas.width = 1024; canvas.height = 1024;
          const ctx = canvas.getContext('2d');

          const N = this.data.lines;
          const step = 1024 / N;

          ctx.clearRect(0,0,1024,1024);

          for (let i=0;i<=N;i++){
            const major = (i % this.data.majorEvery) === 0;
            ctx.strokeStyle = major ? this.data.majorColor : this.data.minorColor;
            ctx.lineWidth = major ? 2 : 1;

            ctx.beginPath(); ctx.moveTo(i*step, 0); ctx.lineTo(i*step, 1024); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i*step); ctx.lineTo(1024, i*step); ctx.stroke();
          }

          const g = ctx.createRadialGradient(512,512,140,512,512,620);
          g.addColorStop(0, 'rgba(0,0,0,0)');
          g.addColorStop(1, 'rgba(0,0,0,0.55)');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,1024,1024);

          const tex = new THREE.CanvasTexture(canvas);
          tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
          tex.repeat.set(this.data.size/6, this.data.size/6);
          tex.anisotropy = 8;

          const apply = () => {
            const mesh = this.el.getObject3D('mesh');
            if (!mesh) return;
            mesh.material.map = tex;
            mesh.material.transparent = true;
            mesh.material.needsUpdate = true;
          };

          if (!this.el.getObject3D('mesh')) this.el.addEventListener('object3dset', apply, { once:true });
          else apply();
        }
      });

      // ----------------------------
      // Neon frame for title
      // ----------------------------
      AFRAME.registerComponent('neon-frame', {
        schema: { w:{type:'number', default: 10}, h:{type:'number', default: 3}, color:{type:'string', default:'#00F0FF'} },
        init() {
          const {w,h,color} = this.data;
          const mk = (pos, scale) => {
            const e = document.createElement('a-box');
            e.setAttribute('position', pos);
            e.setAttribute('scale', scale);
            e.setAttribute('material', `shader: standard; color:#07070d; metalness:0.4; roughness:0.22; emissive:${color}; emissiveIntensity: 1.15;`);
            e.setAttribute('opacity','0.95');
            e.setAttribute('transparent','true');
            e.setAttribute('animation__pulse', 'property: material.emissiveIntensity; dir: alternate; dur: 1400; loop: true; to: 1.55; easing: easeInOutSine');
            this.el.appendChild(e);
          };
          mk(`0 ${h/2} 0`, `${w} 0.06 0.06`);
          mk(`0 ${-h/2} 0`, `${w} 0.06 0.06`);
          mk(`${-w/2} 0 0`, `0.06 ${h} 0.06`);
          mk(`${w/2} 0 0`, `0.06 ${h} 0.06`);
        }
      });

      // ----------------------------
      // Node visual
      // ----------------------------
      AFRAME.registerComponent('mind-node', {
        schema: { label:{default:'Node'}, color:{default:'#00F0FF'}, size:{type:'number', default:0.16} },
        init(){
          const {label, color, size} = this.data;

          this.el.classList.add('hitNode');

          const orb = document.createElement('a-sphere');
          orb.classList.add('hitNode');
          orb.setAttribute('radius', size);
          orb.setAttribute('segments-width', 28);
          orb.setAttribute('segments-height', 18);
          orb.setAttribute('material', `shader: standard; color:#07070d; metalness:0.65; roughness:0.18; emissive:${color}; emissiveIntensity:1.0;`);
          orb.setAttribute('animation__pulse', 'property: material.emissiveIntensity; dir: alternate; dur: 950; loop: true; to: 1.35; easing: easeInOutSine');
          this.el.appendChild(orb);

          const ring = document.createElement('a-torus');
          ring.classList.add('hitNode');
          ring.setAttribute('radius', size * 1.25);
          ring.setAttribute('radius-tubular', Math.max(0.006, size * 0.06));
          ring.setAttribute('segments-tubular', 48);
          ring.setAttribute('rotation', '90 0 0');
          ring.setAttribute('material', `shader: standard; color:#050510; metalness:0.2; roughness:0.35; emissive:${color}; emissiveIntensity:1.2; opacity:0.85; transparent:true;`);
          ring.setAttribute('animation__spin', 'property: rotation; to: 90 360 0; loop: true; dur: 9000; easing: linear');
          this.el.appendChild(ring);

          const plate = document.createElement('a-plane');
          plate.setAttribute('position', `0 ${size*1.55} 0`);
          plate.setAttribute('width', clamp(label.length * 0.12, 0.8, 2.8));
          plate.setAttribute('height', 0.36);
          plate.setAttribute('material', 'shader: standard; color:#02020a; metalness:0.1; roughness:0.9; emissive:#00131a; emissiveIntensity:0.8; opacity:0.72; transparent:true;');
          this.el.appendChild(plate);

          const txt = document.createElement('a-text');
          txt.setAttribute('value', label);
          txt.setAttribute('align', 'center');
          txt.setAttribute('width', 3.2);
          txt.setAttribute('color', color);
          txt.setAttribute('position', `0 ${size*1.55} 0.02`);
          txt.setAttribute('data-role', 'label');
          this.el.appendChild(txt);
        }
      });

      function getNodeLabel(nodeEl){
        const t = nodeEl.querySelector('[data-role="label"]');
        return t ? (t.getAttribute('value') || '') : '';
      }
      function setNodeLabel(nodeEl, label){
        const t = nodeEl.querySelector('[data-role="label"]');
        if (t) t.setAttribute('value', label);
        const plate = nodeEl.querySelector('a-plane');
        if (plate) plate.setAttribute('width', clamp(label.length * 0.12, 0.8, 2.8));
      }

      // ----------------------------
      // Link tube between nodes (world-space)
      // ----------------------------
      AFRAME.registerComponent('link-tube', {
        schema: {
          from: { type: 'selector' },
          to: { type: 'selector' },
          color: { default: '#00F0FF' },
          thickness: { type: 'number', default: 0.012 },
          opacity: { type: 'number', default: 0.9 }
        },
        init(){
          const geom = new THREE.CylinderGeometry(1, 1, 1, 10, 1, true);
          const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color('#050510'),
            emissive: new THREE.Color(this.data.color),
            emissiveIntensity: 1.25,
            metalness: 0.2,
            roughness: 0.35,
            transparent: true,
            opacity: this.data.opacity
          });
          this.mesh = new THREE.Mesh(geom, mat);
          this.el.setObject3D('mesh', this.mesh);

          this._a = new THREE.Vector3();
          this._b = new THREE.Vector3();
          this._dir = new THREE.Vector3();
          this._mid = new THREE.Vector3();
          this._quat = new THREE.Quaternion();
        },
        update(){
          if (!this.mesh?.material) return;
          this.mesh.material.emissive = new THREE.Color(this.data.color);
          this.mesh.material.opacity = this.data.opacity;
          this.mesh.material.needsUpdate = true;
        },
        tick(){
          const {from, to, thickness} = this.data;
          if (!from || !to) return;

          from.object3D.getWorldPosition(this._a);
          to.object3D.getWorldPosition(this._b);

          this._dir.copy(this._b).sub(this._a);
          const len = this._dir.length();
          if (len < 0.0001) return;

          this._mid.copy(this._a).add(this._b).multiplyScalar(0.5);

          this._dir.normalize();
          this._quat.setFromUnitVectors(new THREE.Vector3(0,1,0), this._dir);

          this.mesh.position.copy(this._mid);
          this.mesh.quaternion.copy(this._quat);
          // base cylinder height = 1, scale.y makes height = len
          this.mesh.scale.set(thickness, len, thickness);
        }
      });

      // ----------------------------
      // Mindmap from JSON
      // ----------------------------
      AFRAME.registerComponent('mindmap', {
        schema: { src: { type:'selector' } },
        init(){ this.rebuild(); },
        readJSON(){
          const el = this.data.src;
          if (!el) return null;
          try { return JSON.parse(el.textContent.trim()); }
          catch(e){ console.warn('Bad JSON', e); return null; }
        },
        clear(){ while (this.el.firstChild) this.el.removeChild(this.el.firstChild); },
        rebuild(){
          const data = this.readJSON();
          if (!data) return;
          this.clear();

          (data.nodes||[]).forEach(n=>{
            const nodeEl = document.createElement('a-entity');
            nodeEl.setAttribute('id', n.id);
            nodeEl.setAttribute('position', `${n.pos?.[0] ?? 0} ${n.pos?.[1] ?? 1.6} ${n.pos?.[2] ?? -3}`);
            nodeEl.setAttribute('mind-node', `label: ${n.label ?? n.id}; color: ${n.color ?? '#00F0FF'}; size: ${n.size ?? 0.16}`);
            nodeEl.setAttribute('data-color', n.color ?? '#00F0FF');
            this.el.appendChild(nodeEl);
          });

          (data.links||[]).forEach((l)=>{
            const a = this.el.querySelector(`#${CSS.escape(l.from)}`);
            const b = this.el.querySelector(`#${CSS.escape(l.to)}`);
            if (!a || !b) return;

            const linkEl = document.createElement('a-entity');
            linkEl.setAttribute('link-tube', `from: #${l.from}; to: #${l.to}; color: ${l.color ?? '#00F0FF'}; thickness: ${l.thickness ?? 0.012}; opacity: ${l.opacity ?? 0.9}`);
            linkEl.setAttribute('data-from', l.from);
            linkEl.setAttribute('data-to', l.to);
            this.el.appendChild(linkEl);
          });
        }
      });

      // ----------------------------
      // Selection ring
      // ----------------------------
      AFRAME.registerComponent('selection-ring', {
        init(){
          const ring = document.createElement('a-torus');
          ring.setAttribute('radius', 0.28);
          ring.setAttribute('radius-tubular', 0.012);
          ring.setAttribute('rotation', '90 0 0');
          ring.setAttribute('material', 'shader: standard; color:#050510; metalness:0.2; roughness:0.25; emissive:#00F0FF; emissiveIntensity: 1.55; opacity:0.9; transparent:true;');
          ring.setAttribute('animation__spin', 'property: rotation; to: 90 360 0; loop: true; dur: 2400; easing: linear');
          this.el.appendChild(ring);
        },
        setTarget(nodeEl){
          if (!nodeEl) { this.el.setAttribute('visible','false'); return; }
          nodeEl.object3D.add(this.el.object3D);
          this.el.object3D.position.set(0, 0, 0);
          this.el.setAttribute('visible','true');
        }
      });

      // ----------------------------
      // Locomotion (rig-relative; stable)
      // ----------------------------
      AFRAME.registerComponent('locomotion-rig', {
        schema: {
          leftHand: { type:'selector' },
          rightHand:{ type:'selector' },
          moveSpeed:{ type:'number', default: 2.4 },
          turnSpeed:{ type:'number', default: 72 },
          deadzone:{ type:'number', default: 0.18 }
        },
        init(){
          this._move = {x:0,y:0};
          this._turn = {x:0,y:0};

          const lh = this.data.leftHand;
          const rh = this.data.rightHand;

          if (lh){
            lh.addEventListener('thumbstickmoved', e=>{ this._move.x = e.detail.x; this._move.y = e.detail.y; });
            lh.addEventListener('thumbstickup', ()=>{ this._move.x = 0; this._move.y = 0; });
          }
          if (rh){
            rh.addEventListener('thumbstickmoved', e=>{ this._turn.x = e.detail.x; this._turn.y = e.detail.y; });
            rh.addEventListener('thumbstickup', ()=>{ this._turn.x = 0; this._turn.y = 0; });
          }

          this._tmp = new THREE.Vector3();
        },
        tick(_, dtMs){
          const dt = Math.min(0.05, dtMs/1000);
          const dz = this.data.deadzone;

          // Turn (right stick X)
          const tx = Math.abs(this._turn.x) > dz ? this._turn.x : 0;
          if (tx){
            const turnDeg = this.data.turnSpeed * dt * tx;
            this.el.object3D.rotation.y -= THREE.MathUtils.degToRad(turnDeg);
          }

          // Move (left stick). Oculus y is typically -1 when pushing forward, so forward = -y.
          const mx = Math.abs(this._move.x) > dz ? this._move.x : 0;
          const my = Math.abs(this._move.y) > dz ? this._move.y : 0;
          if (!mx && !my) return;

          const forwardAxis = -my;
          const strafeAxis  = mx;

          const yaw = this.el.object3D.rotation.y;

          // Rig-relative basis (stable regardless of head direction)
          const fwd = this._tmp.set(-Math.sin(yaw), 0, -Math.cos(yaw)); // forward
          const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)); // right

          const move = new THREE.Vector3()
            .copy(fwd).multiplyScalar(forwardAxis)
            .add(right.multiplyScalar(strafeAxis));

          if (move.lengthSq() < 1e-6) return;
          move.normalize();

          this.el.object3D.position.addScaledVector(move, this.data.moveSpeed * dt);
        }
      });

      // ----------------------------
      // Simple VR keyboard (X to open, Trigger to click)
      // ----------------------------
      AFRAME.registerComponent('vr-keyboard', {
        init(){
          this.value = '';
          this.targetNode = null;

          const bg = document.createElement('a-plane');
          bg.classList.add('hitUI');
          bg.setAttribute('width','1.45');
          bg.setAttribute('height','0.78');
          bg.setAttribute('material','shader: standard; color:#02020a; opacity:0.62; transparent:true; emissive:#00131a; emissiveIntensity:0.85; roughness:1.0; metalness:0.0');
          this.el.appendChild(bg);

          const title = document.createElement('a-text');
          title.setAttribute('value','Rename node');
          title.setAttribute('align','center');
          title.setAttribute('width','2.4');
          title.setAttribute('color','#8ff0ff');
          title.setAttribute('position','0 0.32 0.01');
          this.el.appendChild(title);

          this.display = document.createElement('a-text');
          this.display.setAttribute('value','');
          this.display.setAttribute('align','center');
          this.display.setAttribute('width','2.6');
          this.display.setAttribute('color','#e9fbff');
          this.display.setAttribute('position','0 0.24 0.01');
          this.el.appendChild(this.display);

          const keys = [
            'Q','W','E','R','T','Y','U','I','O','P',
            'A','S','D','F','G','H','J','K','L',
            'Z','X','C','V','B','N','M',
            'SPACE','BKSP','DONE'
          ];

          const makeKey = (label, x, y, w=0.12) => {
            const k = document.createElement('a-entity');
            k.classList.add('hitUI');
            k.setAttribute('position', `${x} ${y} 0.01`);

            const box = document.createElement('a-box');
            box.classList.add('hitUI');
            box.setAttribute('width', w);
            box.setAttribute('height','0.08');
            box.setAttribute('depth','0.03');
            box.setAttribute('material', 'shader: standard; color:#07070d; metalness:0.2; roughness:0.4; emissive:#00F0FF; emissiveIntensity:0.55; opacity:0.92; transparent:true');
            k.appendChild(box);

            const t = document.createElement('a-text');
            t.setAttribute('value', label === 'SPACE' ? 'Space' : label);
            t.setAttribute('align','center');
            t.setAttribute('width','1.0');
            t.setAttribute('color','#e9fbff');
            t.setAttribute('position','0 0 0.03');
            k.appendChild(t);

            k.addEventListener('click', ()=> this.onKey(label));
            this.el.appendChild(k);
          };

          let idx = 0;
          for (let i=0;i<10;i++,idx++) makeKey(keys[idx], -0.58 + i*0.13, 0.10, 0.12);
          for (let i=0;i<9;i++,idx++)  makeKey(keys[idx], -0.52 + i*0.13, 0.00, 0.12);
          for (let i=0;i<7;i++,idx++)  makeKey(keys[idx], -0.39 + i*0.13, -0.10, 0.12);

          makeKey('SPACE', -0.24, -0.24, 0.46);
          makeKey('BKSP',   0.29, -0.24, 0.22);
          makeKey('DONE',   0.52, -0.24, 0.22);

          const frame = document.createElement('a-entity');
          frame.setAttribute('neon-frame','w: 1.52; h: 0.86; color: #00F0FF');
          frame.setAttribute('position','0 0 0.02');
          this.el.appendChild(frame);
        },
        openFor(nodeEl){
          this.targetNode = nodeEl;
          this.value = (getNodeLabel(nodeEl) || '').slice(0, 60);
          this.display.setAttribute('value', this.value || ' ');

          // place in front of camera
          const cam = document.querySelector('#camera');
          const pos = new THREE.Vector3();
          const dir = new THREE.Vector3();
          cam.object3D.getWorldPosition(pos);
          cam.object3D.getWorldDirection(dir);
          dir.y = 0; dir.normalize();

          const place = pos.clone().add(dir.multiplyScalar(1.15));
          place.y = 1.55;

          this.el.object3D.position.copy(place);
          this.el.object3D.lookAt(pos.x, 1.55, pos.z);

          this.el.setAttribute('visible','true');
        },
        close(){
          this.el.setAttribute('visible','false');
          this.targetNode = null;
        },
        onKey(k){
          if (!this.targetNode) return;

          if (k === 'DONE'){
            setNodeLabel(this.targetNode, (this.value.trim() || 'Node'));
            this.close();
            return;
          }
          if (k === 'BKSP'){
            this.value = this.value.slice(0, -1);
          } else if (k === 'SPACE'){
            this.value += ' ';
          } else {
            this.value += k;
          }
          this.value = this.value.slice(0, 60);
          this.display.setAttribute('value', this.value || ' ');
        }
      });

      // ----------------------------
      // Main controller logic:
      // Trigger select / click UI
      // Grip drag node
      // Both grips => manipulate whole workspace (move/rotate/zoom)
      // A add node at ray hit surface (or in front)
      // B delete selected
      // Y link mode
      // X rename
      // ----------------------------
      AFRAME.registerComponent('mind-controls', {
        schema: {
          leftHand: { type:'selector' },
          rightHand:{ type:'selector' },
          workspace:{ type:'selector' },
          root:     { type:'selector' },
          ring:     { type:'selector' },
          keyboard: { type:'selector' }
        },
        init(){
          this.selected = null;
          this.linkFrom = null;

          this.gripHeld = { left:false, right:false };
          this.dragNode = { left:null, right:null };
          this.dragOffsetW = { left:new THREE.Vector3(), right:new THREE.Vector3() };

          this.worldMode = false;
          this.wm = {
            startDist: 1,
            startScale: 1,
            startRotY: 0,
            startPos: new THREE.Vector3(),
            startMid: new THREE.Vector3(),
            startAngle: 0
          };

          this._tmpA = new THREE.Vector3();
          this._tmpB = new THREE.Vector3();
          this._tmpC = new THREE.Vector3();

          this.ringComp = this.data.ring?.components['selection-ring'];
          this.kbComp   = this.data.keyboard?.components['vr-keyboard'];

          const lh = this.data.leftHand;
          const rh = this.data.rightHand;

          lh.addEventListener('triggerdown', () => this.onTrigger(lh));
          rh.addEventListener('triggerdown', () => this.onTrigger(rh));

          lh.addEventListener('gripdown', () => this.onGripDown('left', lh));
          rh.addEventListener('gripdown', () => this.onGripDown('right', rh));
          lh.addEventListener('gripup',   () => this.onGripUp('left'));
          rh.addEventListener('gripup',   () => this.onGripUp('right'));

          // Buttons
          rh.addEventListener('abuttondown', ()=> this.addNodeFromRay(rh));
          rh.addEventListener('bbuttondown', ()=> this.deleteSelected());
          lh.addEventListener('ybuttondown', ()=> this.toggleLinkMode());
          lh.addEventListener('xbuttondown', ()=> this.renameSelected());

          // Desktop JSON helpers wiring
          this.setupJSONDesktop();
        },

        // --- Ray helpers
        getRayHit(handEl){
          const ray = handEl?.components?.raycaster;
          const hits = ray?.intersections;
          if (!hits || !hits.length) return null;
          return hits[0]; // closest
        },
        findHit(handEl, cls){
          const ray = handEl?.components?.raycaster;
          const hits = ray?.intersections;
          if (!hits || !hits.length) return null;

          for (const hit of hits){
            let el = hit.object?.el;
            while (el && el !== this.el.sceneEl){
              if (el.classList?.contains(cls)) return { el, hit };
              el = el.parentEl;
            }
          }
          return null;
        },

        // --- Selection & UI clicks
        onTrigger(handEl){
          // 1) If keyboard/UI is hit => click it
          const ui = this.findHit(handEl, 'hitUI');
          if (ui){
            ui.el.emit('click');
            haptic(handEl, 0.22, 28);
            return;
          }

          // 2) Node select
          const nodeHit = this.findHit(handEl, 'hitNode');
          if (!nodeHit) return;

          const nodeEl = this.getNodeEntity(nodeHit.el);
          if (!nodeEl) return;

          // link flow
          if (this.linkFrom && this.linkFrom !== nodeEl){
            this.createLink(this.linkFrom, nodeEl);
            this.linkFrom = null;
          }

          this.selectNode(nodeEl);
          haptic(handEl, 0.25, 30);
        },

        getNodeEntity(anyEl){
          // climb up to entity that has mind-node component
          let el = anyEl;
          while (el && el !== this.el.sceneEl){
            if (el.components?.['mind-node']) return el;
            el = el.parentEl;
          }
          return null;
        },

        selectNode(nodeEl){
          this.selected = nodeEl;
          if (this.ringComp) this.ringComp.setTarget(nodeEl);
          nodeEl.setAttribute('animation__sel','property: scale; to: 1.08 1.08 1.08; dur: 120; easing: easeOutQuad');
        },

        // --- Link mode
        toggleLinkMode(){
          if (!this.selected) return;
          this.linkFrom = this.selected;
          haptic(this.data.leftHand, 0.35, 55);
        },

        // --- Rename
        renameSelected(){
          if (!this.selected || !this.kbComp) return;
          this.kbComp.openFor(this.selected);
          haptic(this.data.leftHand, 0.25, 40);
        },

        // --- Delete
        deleteSelected(){
          if (!this.selected) return;

          const root = this.data.root;
          const id = this.selected.id;

          // remove links referencing id
          root.querySelectorAll('[link-tube]').forEach(el=>{
            const from = el.getAttribute('data-from');
            const to   = el.getAttribute('data-to');
            if (from === id || to === id) el.parentNode && el.parentNode.removeChild(el);
          });

          // remove node
          const gone = this.selected;
          this.selected = null;
          this.linkFrom = null;
          if (this.ringComp) this.ringComp.setTarget(null);
          gone.parentNode && gone.parentNode.removeChild(gone);

          haptic(this.data.rightHand, 0.40, 70);
        },

        // --- Add node (A): at ray hit surface, otherwise in front of camera
        addNodeFromRay(handEl){
          const root = this.data.root;
          const ws = this.data.workspace;

          const hitSurface = this.findHit(handEl, 'hitSurface');
          let spawnWorld = new THREE.Vector3();

          if (hitSurface){
            spawnWorld.copy(hitSurface.hit.point);
            spawnWorld.y = Math.max(0.6, spawnWorld.y); // keep above floor a bit if needed
          } else {
            const cam = document.querySelector('#camera');
            const camPos = new THREE.Vector3();
            const dir = new THREE.Vector3();
            cam.object3D.getWorldPosition(camPos);
            cam.object3D.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            spawnWorld.copy(camPos).add(dir.multiplyScalar(1.8));
            spawnWorld.y = 1.55;
          }

          // convert world -> root local
          const local = spawnWorld.clone();
          root.object3D.worldToLocal(local);

          const palette = ['#00F0FF','#FF4FD8','#7CFF6B','#FFD24D','#9B7CFF'];
          const color = palette[Math.floor(Math.random()*palette.length)];
          const label = ['Idea','Note','Task','Branch','Signal','Edge'][Math.floor(Math.random()*6)];

          const id = niceId('n');
          const nodeEl = document.createElement('a-entity');
          nodeEl.setAttribute('id', id);
          nodeEl.setAttribute('position', `${local.x.toFixed(3)} ${local.y.toFixed(3)} ${local.z.toFixed(3)}`);
          nodeEl.setAttribute('mind-node', `label: ${label}; color: ${color}; size: 0.15`);
          nodeEl.setAttribute('data-color', color);
          root.appendChild(nodeEl);

          // auto-link if linkFrom armed OR if there is a selected node
          if (this.linkFrom && this.linkFrom !== nodeEl){
            this.createLink(this.linkFrom, nodeEl, color);
            this.linkFrom = null;
          } else if (this.selected && this.selected !== nodeEl){
            // optional: create link from selected when adding
            this.createLink(this.selected, nodeEl, color);
          }

          this.selectNode(nodeEl);
          haptic(handEl, 0.32, 55);
        },

        createLink(fromEl, toEl, color){
          const root = this.data.root;
          if (!fromEl || !toEl) return;

          // avoid duplicates
          const exists = root.querySelector(`[data-from="${fromEl.id}"][data-to="${toEl.id}"],[data-from="${toEl.id}"][data-to="${fromEl.id}"]`);
          if (exists) return;

          const c = color || fromEl.getAttribute('data-color') || '#00F0FF';

          const linkEl = document.createElement('a-entity');
          linkEl.setAttribute('link-tube', `from: #${fromEl.id}; to: #${toEl.id}; color: ${c}; thickness: 0.012; opacity: 0.9`);
          linkEl.setAttribute('data-from', fromEl.id);
          linkEl.setAttribute('data-to', toEl.id);
          root.appendChild(linkEl);

          haptic(this.data.leftHand, 0.20, 30);
        },

        // --- Grip handling: single grip = drag node; both grips = world mode
        onGripDown(side, handEl){
          this.gripHeld[side] = true;

          // If the other grip is already held => start world mode immediately
          if (this.gripHeld.left && this.gripHeld.right){
            this.startWorldMode();
            haptic(this.data.leftHand, 0.25, 40);
            haptic(this.data.rightHand, 0.25, 40);
            return;
          }

          // else: try grab node under this hand ray
          const nodeHit = this.findHit(handEl, 'hitNode');
          if (!nodeHit) return;

          const nodeEl = this.getNodeEntity(nodeHit.el);
          if (!nodeEl) return;

          this.selectNode(nodeEl);

          // store world offset: nodeWorld - handWorld
          const handW = getWorldPos(handEl, this._tmpA);
          const nodeW = getWorldPos(nodeEl, this._tmpB);
          this.dragNode[side] = nodeEl;
          this.dragOffsetW[side].copy(nodeW).sub(handW);

          haptic(handEl, 0.28, 45);
        },

        onGripUp(side){
          this.gripHeld[side] = false;
          this.dragNode[side] = null;

          // leaving world mode if one grip released
          if (this.worldMode && !(this.gripHeld.left && this.gripHeld.right)){
            this.worldMode = false;
          }
        },

        startWorldMode(){
          this.worldMode = true;
          // cancel node drags
          this.dragNode.left = null;
          this.dragNode.right = null;

          const ws = this.data.workspace;
          const lh = this.data.leftHand;
          const rh = this.data.rightHand;

          const lp = getWorldPos(lh, this._tmpA);
          const rp = getWorldPos(rh, this._tmpB);

          const mid = lp.clone().add(rp).multiplyScalar(0.5);
          const vec = rp.clone().sub(lp); vec.y = 0;

          this.wm.startDist = Math.max(0.0001, lp.distanceTo(rp));
          this.wm.startScale = ws.object3D.scale.x;
          this.wm.startRotY  = ws.object3D.rotation.y;
          this.wm.startPos.copy(ws.object3D.position);
          this.wm.startMid.copy(mid);
          this.wm.startAngle = Math.atan2(vec.z, vec.x);
        },

        tick(){
          const root = this.data.root;
          const ws = this.data.workspace;

          // World mode: both grips held => manipulate workspace
          if (this.worldMode && this.gripHeld.left && this.gripHeld.right){
            const lh = this.data.leftHand;
            const rh = this.data.rightHand;

            const lp = getWorldPos(lh, this._tmpA);
            const rp = getWorldPos(rh, this._tmpB);

            // scale
            const dist = Math.max(0.0001, lp.distanceTo(rp));
            const scaleFactor = dist / this.wm.startDist;
            const s = clamp(this.wm.startScale * scaleFactor, 0.20, 5.0);
            ws.object3D.scale.set(s, s, s);

            // rotation (Y) via hand vector angle
            const vec = rp.clone().sub(lp); vec.y = 0;
            const ang = Math.atan2(vec.z, vec.x);
            const dAng = ang - this.wm.startAngle;
            ws.object3D.rotation.y = this.wm.startRotY + dAng;

            // pan via midpoint delta
            const mid = lp.clone().add(rp).multiplyScalar(0.5);
            const delta = mid.clone().sub(this.wm.startMid);
            ws.object3D.position.copy(this.wm.startPos).add(delta);

            return;
          }

          // Node dragging (single grip)
          for (const side of ['left','right']){
            const node = this.dragNode[side];
            if (!node) continue;

            const handEl = (side === 'left') ? this.data.leftHand : this.data.rightHand;

            const handW = getWorldPos(handEl, this._tmpA);
            const desiredW = handW.clone().add(this.dragOffsetW[side]);

            // convert world -> root local (because workspace might be transformed)
            const local = desiredW.clone();
            root.object3D.worldToLocal(local);

            node.setAttribute('position', `${local.x} ${local.y} ${local.z}`);
          }
        },

        // --- JSON Desktop helpers
        exportJSON(){
          const root = this.data.root;
          const nodes = [];
          root.querySelectorAll('[mind-node]').forEach(n=>{
            const pos = n.getAttribute('position');
            const label = getNodeLabel(n) || n.id;
            const attr = n.getAttribute('mind-node');
            nodes.push({
              id: n.id,
              label,
              pos: [pos.x, pos.y, pos.z],
              color: attr?.color || n.getAttribute('data-color') || '#00F0FF',
              size: attr?.size || 0.16
            });
          });

          const links = [];
          root.querySelectorAll('[link-tube]').forEach(l=>{
            const lt = l.getAttribute('link-tube');
            links.push({
              from: l.getAttribute('data-from'),
              to: l.getAttribute('data-to'),
              color: lt?.color || '#00F0FF',
              thickness: lt?.thickness || 0.012
            });
          });

          const obj = { nodes, links };
          const script = document.getElementById('mindmap-json');
          script.textContent = JSON.stringify(obj, null, 2);

          const box = document.getElementById('jsonBox');
          box.value = script.textContent;
        },

        setupJSONDesktop(){
          const toggleBtn = document.getElementById('toggleJson');
          const applyBtn  = document.getElementById('applyJson');
          const exportBtn = document.getElementById('exportJson');
          const box = document.getElementById('jsonBox');
          const jsonScript = document.getElementById('mindmap-json');
          const root = this.data.root;

          const syncFromScript = () => { box.value = jsonScript.textContent.trim(); };

          toggleBtn.addEventListener('click', () => {
            const open = box.style.display !== 'none';
            box.style.display = open ? 'none' : 'block';
            if (!open) syncFromScript();
          });

          applyBtn.addEventListener('click', () => {
            try {
              const parsed = JSON.parse(box.value);
              jsonScript.textContent = JSON.stringify(parsed, null, 2);
              const mm = root?.components?.mindmap;
              if (mm) mm.rebuild();
            } catch(e) {
              alert('JSON error:\n' + e.message);
            }
          });

          exportBtn.addEventListener('click', () => {
            this.exportJSON();
            box.style.display = 'block';
          });
        }
      });
    </script>
  </a-scene>
</body>
</html>
