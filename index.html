<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Noda Minimal Smoke Test (verbose logs)</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
    .box { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 10px 0; }
    .ok { background:#e9fbe9; }
    .bad { background:#ffe9e9; }
    .mono { font-family: ui-monospace, Menlo, Monaco, Consolas, monospace; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #999; background:#f7f7f7; cursor:pointer; margin-right: 8px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; margin: 0; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
  </style>

  <!-- –¢–í–û–ô noda.js -->
  <script
    src="./noda.js"
    onload="window.__nodaJsLoaded=true; window.__log('‚úÖ custom noda.js loaded');"
    onerror="window.__nodaJsError=true; window.__log('‚ùå custom noda.js failed to load');"
  ></script>

  <script>
    function $(id){ return document.getElementById(id); }

    function setBox(id, ok, html) {
      const el = $(id);
      el.className = "box " + (ok ? "ok" : "bad");
      el.innerHTML = html;
    }

    function nowTs() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,"0")}`;
    }

    function __log(msg) {
      const el = $("log");
      if (!el) return;
      el.textContent = `[${nowTs()}] ${msg}\n` + el.textContent;
      el.textContent = el.textContent.slice(0, 16000);
    }
    window.__log = __log;

    function logClick(name) {
      __log(`üñ±Ô∏è CLICK: ${name}`);
    }

    function withTimeout(p, ms, label="timeout") {
      return Promise.race([
        p,
        new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
      ]);
    }

    function safeStringify(obj) {
      try { return JSON.stringify(obj, null, 2); } catch (e) { return String(obj); }
    }

    function getNodaState() {
      const jsLoaded = !!window.__nodaJsLoaded;
      const jsError  = !!window.__nodaJsError;
      const hasNoda  = !!window.noda;

      let installed = null;
      let installedOk = false;

      if (hasNoda) {
        try {
          installed = window.noda.isInstalled();
          installedOk = (installed === true);
        } catch (e) {
          installed = "ERR: " + String(e);
        }
      }

      return { jsLoaded, jsError, hasNoda, installed, installedOk };
    }

    function snapshot() {
      const st = getNodaState();

      setBox("script", !st.jsError, `
        <b>Script</b><br/>
        loaded: <span class="mono">${st.jsLoaded}</span><br/>
        error: <span class="mono">${st.jsError}</span>
      `);

      setBox("obj", st.hasNoda, `
        <b>window.noda</b><br/>
        exists: <span class="mono">${st.hasNoda}</span>
      `);

      setBox("ctx", st.installedOk, `
        <b>VR context</b><br/>
        isInstalled(): <span class="mono">${String(st.installed)}</span>
      `);

      // –≤–∫–ª—é—á–∞–µ–º/–≤—ã–∫–ª—é—á–∞–µ–º –∫–Ω–æ–ø–∫–∏ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É (–Ω–æ –∫–ª–∏–∫–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –±—É–¥—É—Ç –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å—Å—è)
      const enabled = st.jsLoaded && st.hasNoda && st.installedOk;
      $("btnClear").disabled = !enabled;
      $("btnOne").disabled = !enabled;
      $("btnMany").disabled = !enabled;
      $("btnList").disabled = !enabled;
    }

    async function safeGetUser() {
      const st = getNodaState();
      if (!st.hasNoda) throw new Error("window.noda missing");
      if (!st.installedOk) throw new Error("isInstalled() is false");

      __log("getUser() start‚Ä¶");
      const user = await withTimeout(window.noda.getUser(), 2000, "getUser timeout");
      __log("getUser() result: " + safeStringify(user));

      // –ù–ï –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º –ø–æ–ª–µ userId ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∂–µ–º –≤—Å—ë
      $("userId").textContent = safeStringify(user);
      return user;
    }

    async function listNodesVerbose() {
      const st = getNodaState();
      if (!st.hasNoda) throw new Error("window.noda missing");
      if (!st.installedOk) throw new Error("isInstalled() is false");

      __log("listNodes() start‚Ä¶");
      // listNodes –≤ –∏—Ö –ø—Ä–∏–º–µ—Ä–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç props; –º–æ–∂–Ω–æ –∏ –ø—É—Å—Ç–æ–π –æ–±—ä–µ–∫—Ç
      const res = await withTimeout(window.noda.listNodes({}), 3000, "listNodes timeout");
      const count = (res && res.nodes && Array.isArray(res.nodes)) ? res.nodes.length : 0;

      __log(`listNodes() OK: count=${count}`);
      if (count > 0) {
        const first = res.nodes[0];
        __log("first node sample: " + safeStringify(first));
      }
      return { count, res };
    }

    async function clearMap() {
      logClick("Clear map");
      try {
        const st = getNodaState();
        if (!st.hasNoda) throw new Error("window.noda missing");
        if (!st.installedOk) throw new Error("isInstalled() is false");

        __log("clearMap() start‚Ä¶");
        await withTimeout(window.noda.clearMap(), 3000, "clearMap timeout");
        __log("clearMap() OK");
        setBox("status", true, `<b>Status</b><br/>Map cleared`);
      } catch (e) {
        __log("clearMap ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>clearMap ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    async function createOneHugeNode() {
      logClick("Create ONE huge node");
      try {
        const st = getNodaState();
        if (!st.hasNoda) throw new Error("window.noda missing");
        if (!st.installedOk) throw new Error("isInstalled() is false");

        const payload = {
          uuid: "smoke:visible",
          title: "VISIBLE NODE (relativeTo=User)",
          color: "F44336",
          opacity: 1,
          shape: "Ball",
          size: 45,
          notes: "If you see this ‚Äî createNode works.",
          location: { x: 0, y: 0, z: -1.0, relativeTo: "User" }
        };

        __log("createNode() payload: " + safeStringify(payload));
        __log("createNode() start‚Ä¶");

        const node = await withTimeout(window.noda.createNode(payload), 5000, "createNode timeout");
        __log("createNode() OK: " + safeStringify(node));

        setBox("status", true, `<b>Status</b><br/>Created node: <span class="mono">${node && node.uuid ? node.uuid : "(no uuid)"}</span>`);

        // –ü—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –Ω–æ–¥–∞ —Ä–µ–∞–ª—å–Ω–æ ‚Äú–≤ —Å–∏—Å—Ç–µ–º–µ‚Äù
        await listNodesVerbose();

      } catch (e) {
        __log("createNode ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>createNode ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    async function createManyNodes() {
      logClick("Create MANY nodes");
      try {
        const st = getNodaState();
        if (!st.hasNoda) throw new Error("window.noda missing");
        if (!st.installedOk) throw new Error("isInstalled() is false");

        const N = 60; // –ø–æ–º–µ–Ω—å—à–µ –¥–ª—è —Ç–µ—Å—Ç–∞, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –æ—Ç—Ä–∞–±–æ—Ç–∞–ª–æ –±—ã—Å—Ç—Ä–æ
        __log("createManyNodes start N=" + N);

        for (let i = 0; i < N; i++) {
          const row = i % 10;
          const col = Math.floor(i / 10);

          const payload = {
            uuid: "bulk:n" + i,
            title: "#" + i,
            color: (i % 3 === 0) ? "2196F3" : (i % 3 === 1) ? "4CAF50" : "FFB020",
            opacity: 1,
            shape: (i % 4 === 0) ? "Star" : (i % 4 === 1) ? "Diamond" : (i % 4 === 2) ? "Hourglass" : "Box",
            size: 10,
            notes: "bulk " + i,
            location: {
              x: (row - 4.5) * 0.18,
              y: (col - 2.5) * 0.18,
              z: -1.4 - (i % 4) * 0.15,
              relativeTo: "User"
            }
          };

          __log("createNode #" + i + " start‚Ä¶");
          await withTimeout(window.noda.createNode(payload), 5000, "createNode timeout #" + i);
          __log("createNode #" + i + " OK");
        }

        // link (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        const linkPayload = {
          uuid: "bulk:link",
          fromUuid: "bulk:n0",
          toUuid: "bulk:n59",
          title: "range",
          color: "171717",
          shape: "Dash",
          size: 2,
          curve: "None",
          trail: "Ring",
          selected: false
        };
        __log("createLink payload: " + safeStringify(linkPayload));
        __log("createLink start‚Ä¶");
        await withTimeout(window.noda.createLink(linkPayload), 5000, "createLink timeout");
        __log("createLink OK");

        setBox("status", true, `<b>Status</b><br/>Created ${N} nodes + 1 link`);

        await listNodesVerbose();

      } catch (e) {
        __log("createMany ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>createMany ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    async function listNodesButton() {
      logClick("List nodes");
      try {
        const { count } = await listNodesVerbose();
        setBox("status", true, `<b>Status</b><br/>listNodes OK: count=${count}`);
      } catch (e) {
        __log("listNodes ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>listNodes ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    document.addEventListener("DOMContentLoaded", async () => {
      __log("DOMContentLoaded");

      // –°–æ–±—ã—Ç–∏—è (–µ—Å–ª–∏ –æ–Ω–∏ –≤–æ–æ–±—â–µ —à–ª—é—Ç—Å—è)
      try {
        if (window.noda) {
          window.noda.onNodeCreated = (n) => __log("EVENT onNodeCreated: " + (n && n.uuid));
          window.noda.onNodeUpdated = (n) => __log("EVENT onNodeUpdated: " + (n && n.uuid));
          window.noda.onLinkCreated = (l) => __log("EVENT onLinkCreated: " + (l && l.uuid));
          window.noda.onInitialized = () => __log("EVENT onInitialized fired");
        }
      } catch (e) {
        __log("event wiring error: " + String(e));
      }

      setInterval(snapshot, 300);

      // –ü–æ–ø—Ä–æ–±—É–µ–º getUser, –Ω–æ –Ω–µ —Å—á–∏—Ç–∞–µ–º —ç—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω—ã–º
      setTimeout(async () => {
        try {
          const st = getNodaState();
          if (st.jsLoaded && st.hasNoda && st.installedOk) {
            await safeGetUser();
            setBox("status", true, `<b>Status</b><br/>Ready. (getUser may be missing userId ‚Äî see User JSON)`);
          } else {
            setBox("status", false, `<b>Status</b><br/>Not ready yet (script/noda/context)`);
          }
        } catch (e) {
          __log("safeGetUser ERROR (non-fatal): " + String(e));
          $("userId").textContent = "getUser failed: " + String(e);
          setBox("status", true, `<b>Status</b><br/>Ready (context ok), but getUser failed/timeout. Try createNode anyway.`);
        }
      }, 700);
    });
  </script>
</head>

<body>
  <h2>Noda Minimal Smoke Test (verbose)</h2>

  <div id="script" class="box bad">‚Ä¶</div>
  <div id="obj" class="box bad">‚Ä¶</div>
  <div id="ctx" class="box bad">‚Ä¶</div>

  <div id="status" class="box bad"><b>Status</b><br/>waiting‚Ä¶</div>

  <div class="box">
    <b>User JSON:</b>
    <pre id="userId" class="mono">waiting‚Ä¶</pre>
  </div>

  <div class="box">
    <div class="row">
      <button id="btnClear" onclick="clearMap()">Clear map</button>
      <button id="btnOne" onclick="createOneHugeNode()">Create ONE4444 huge node</button>
      <button id="btnMany" onclick="createManyNodes()">Create MANY nodes</button>
      <button id="btnList" onclick="listNodesButton()">List nodes</button>
    </div>
    <div style="margin-top:8px; font-size:12px;">
      –í –ª–æ–≥ –ø–∏—à–µ—Ç—Å—è –∫–∞–∂–¥—ã–π –∫–ª–∏–∫ + —Å—Ç–∞—Ä—Ç/—É—Å–ø–µ—Ö/–æ—à–∏–±–∫–∞ –∫–∞–∂–¥–æ–≥–æ API-–≤—ã–∑–æ–≤–∞.
    </div>
  </div>

  <div class="box">
    <b>Log</b>
    <pre id="log" class="mono"></pre>
  </div>
</body>
</html>
