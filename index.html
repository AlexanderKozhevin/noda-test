<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Noda Smoke Test (super verbose)</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
    .box { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 10px 0; }
    .ok { background:#e9fbe9; }
    .bad { background:#ffe9e9; }
    .mono { font-family: ui-monospace, Menlo, Monaco, Consolas, monospace; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #999; background:#f7f7f7; cursor:pointer; margin-right: 8px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; margin: 0; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
  </style>

  <!-- —Ç–≤–æ–π noda.js -->
  <script
    src="./noda.js"
    onload="window.__nodaJsLoaded=true; window.__log('‚úÖ noda.js loaded');"
    onerror="window.__nodaJsError=true; window.__log('‚ùå noda.js failed to load');"
  ></script>

  <script>
    function $(id){ return document.getElementById(id); }

    function setBox(id, ok, html) {
      const el = $(id);
      el.className = "box " + (ok ? "ok" : "bad");
      el.innerHTML = html;
    }

    function nowTs() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,"0")}`;
    }

    function __log(msg) {
      const el = $("log");
      if (!el) return;
      el.textContent = `[${nowTs()}] ${msg}\n` + el.textContent;
      el.textContent = el.textContent.slice(0, 20000);
    }
    window.__log = __log;

    function logClick(name) { __log(`üñ±Ô∏è CLICK: ${name}`); }

    function withTimeout(p, ms, label="timeout") {
      return Promise.race([
        p,
        new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
      ]);
    }

    function safeStringify(obj) {
      try { return JSON.stringify(obj, null, 2); } catch (e) { return String(obj); }
    }

    function getNodaState() {
      const jsLoaded = !!window.__nodaJsLoaded;
      const jsError  = !!window.__nodaJsError;
      const hasNoda  = !!window.noda;

      let installed = null;
      let installedOk = false;
      if (hasNoda) {
        try {
          installed = window.noda.isInstalled();
          installedOk = (installed === true);
        } catch (e) {
          installed = "ERR: " + String(e);
        }
      }
      return { jsLoaded, jsError, hasNoda, installed, installedOk };
    }

    function snapshot() {
      const st = getNodaState();

      setBox("script", !st.jsError, `
        <b>Script</b><br/>
        loaded: <span class="mono">${st.jsLoaded}</span><br/>
        error: <span class="mono">${st.jsError}</span>
      `);

      setBox("obj", st.hasNoda, `
        <b>window.noda</b><br/>
        exists: <span class="mono">${st.hasNoda}</span>
      `);

      setBox("ctx", st.installedOk, `
        <b>VR context</b><br/>
        isInstalled(): <span class="mono">${String(st.installed)}</span>
      `);

      const enabled = st.jsLoaded && st.hasNoda && st.installedOk;
      $("btnClear").disabled = !enabled;
      $("btnOne").disabled = !enabled;
      $("btnList").disabled = !enabled;
      $("btnOrigin").disabled = !enabled;
    }

    async function safeGetUser() {
      const st = getNodaState();
      if (!st.hasNoda) throw new Error("window.noda missing");
      if (!st.installedOk) throw new Error("isInstalled() is false");

      __log("getUser() start‚Ä¶");
      const user = await withTimeout(window.noda.getUser(), 8000, "getUser timeout");
      __log("getUser() result: " + safeStringify(user));
      $("userJson").textContent = safeStringify(user);
      return user;
    }

    async function listNodesVerbose() {
      const st = getNodaState();
      if (!st.hasNoda) throw new Error("window.noda missing");
      if (!st.installedOk) throw new Error("isInstalled() is false");

      __log("listNodes(null) start‚Ä¶");
      // IMPORTANT: docs say null returns all nodes
      const res = await withTimeout(window.noda.listNodes(null), 20000, "listNodes timeout");
      const count = (res && Array.isArray(res.nodes)) ? res.nodes.length : 0;

      __log(`listNodes OK: count=${count}`);
      if (count > 0) __log("first node: " + safeStringify(res.nodes[0]));
      return { count, res };
    }

    async function clearMap() {
      logClick("Clear map");
      try {
        __log("clearMap() start‚Ä¶");
        await withTimeout(window.noda.clearMap(), 15000, "clearMap timeout");
        __log("clearMap OK");
        setBox("status", true, `<b>Status</b><br/>Map cleared`);
      } catch (e) {
        __log("clearMap ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>clearMap ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    // –≤–∞—Ä–∏–∞–Ω—Ç 1: relativeTo=User, y=1.3 (—É—Ä–æ–≤–µ–Ω—å –≥–ª–∞–∑), z=-2 (–ø–µ—Ä–µ–¥ —Ç–æ–±–æ–π)
    async function createVisibleNode_User() {
      logClick("Create node (User coords)");
      try {
        const payload = {
          uuid: "smoke:visible:user",
          title: "VISIBLE (User) y=1.3 z=-2.0",
          color: "#F44336",
          opacity: 1,
          shape: "Box",
          size: 30,
          selected: true,
          notes: "–ï—Å–ª–∏ –Ω–µ –≤–∏–¥–Ω–æ ‚Äî –ø–æ–ø—Ä–æ–±—É–π –≤–∞—Ä–∏–∞–Ω—Ç Origin –Ω–∏–∂–µ.",
          location: { x: 0, y: 1.3, z: -2.0, relativeTo: "User" }
        };

        __log("createNode payload: " + safeStringify(payload));
        __log("createNode start‚Ä¶");
        const node = await withTimeout(window.noda.createNode(payload), 20000, "createNode timeout");
        __log("createNode OK: " + safeStringify(node));
        setBox("status", true, `<b>Status</b><br/>Created node: <span class="mono">${node?.uuid ?? "(no uuid)"}</span>`);
      } catch (e) {
        __log("createNode ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>createNode ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    // –≤–∞—Ä–∏–∞–Ω—Ç 2: relativeTo=Origin ‚Äî –∏–Ω–æ–≥–¥–∞ —ç—Ç–æ ‚Äú–Ω–∞–¥—ë–∂–Ω–µ–µ‚Äù –≤–∏–∑—É–∞–ª—å–Ω–æ
    async function createVisibleNode_Origin() {
      logClick("Create node (Origin coords)");
      try {
        const payload = {
          uuid: "smoke:visible:origin",
          title: "VISIBLE (Origin) y=1.3 z=-2.0",
          color: "#2196F3",
          opacity: 1,
          shape: "Ball",
          size: 30,
          selected: true,
          notes: "Origin fallback",
          location: { x: 0, y: 1.3, z: -2.0, relativeTo: "Origin" }
        };

        __log("createNode payload: " + safeStringify(payload));
        __log("createNode start‚Ä¶");
        const node = await withTimeout(window.noda.createNode(payload), 20000, "createNode timeout");
        __log("createNode OK: " + safeStringify(node));
        setBox("status", true, `<b>Status</b><br/>Created origin node: <span class="mono">${node?.uuid ?? "(no uuid)"}</span>`);
      } catch (e) {
        __log("createNode ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>createNode ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    async function listNodesButton() {
      logClick("List nodes");
      try {
        const { count } = await listNodesVerbose();
        setBox("status", true, `<b>Status</b><br/>listNodes OK: count=${count}`);
      } catch (e) {
        __log("listNodes ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>listNodes ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    document.addEventListener("DOMContentLoaded", async () => {
      __log("DOMContentLoaded");

      // —Å–æ–±—ã—Ç–∏—è –∏–∑ VR (–µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–∏—Ö–æ–¥—è—Ç)
      try {
        if (window.noda) {
          window.noda.onNodeCreated = (n) => __log("EVENT onNodeCreated: " + (n && n.uuid));
          window.noda.onNodeUpdated = (n) => __log("EVENT onNodeUpdated: " + (n && n.uuid));
          window.noda.onInitialized = () => __log("EVENT onInitialized fired");
        }
      } catch (e) {
        __log("event wiring error: " + String(e));
      }

      setInterval(snapshot, 300);

      setTimeout(async () => {
        try {
          const st = getNodaState();
          if (st.jsLoaded && st.hasNoda && st.installedOk) {
            await safeGetUser(); // –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –Ω–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ
            setBox("status", true, `<b>Status</b><br/>Ready`);
          } else {
            setBox("status", false, `<b>Status</b><br/>Not ready yet`);
          }
        } catch (e) {
          __log("getUser non-fatal: " + String(e));
          $("userJson").textContent = "getUser failed/timeout: " + String(e);
          setBox("status", true, `<b>Status</b><br/>Ready (but getUser failed). Try createNode.`);
        }
      }, 700);
    });
  </script>
</head>

<body>
  <h2>Noda Smoke Test (super verbose)</h2>

  <div id="script" class="box bad">‚Ä¶</div>
  <div id="obj" class="box bad">‚Ä¶</div>
  <div id="ctx" class="box bad">‚Ä¶</div>

  <div id="status" class="box bad"><b>Status</b><br/>waiting‚Ä¶</div>

  <div class="box">
    <b>User JSON:</b>
    <pre id="userJson" class="mono">waiting‚Ä¶</pre>
    <div style="margin-top:8px; font-size:12px;">
      –í –¥–æ–∫–∞—Ö —Å–∫–∞–∑–∞–Ω–æ, —á—Ç–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å userId, –Ω–æ –º—ã –ø–µ—á–∞—Ç–∞–µ–º –≤–µ—Å—å –æ–±—ä–µ–∫—Ç –∫–∞–∫ –µ—Å—Ç—å. :contentReference[oaicite:2]{index=2}
    </div>
  </div>

  <div class="box">
    <div class="row">
      <button id="btnClear" onclick="clearMap()">Clear map</button>
      <button id="btnOne" onclick="createVisibleNode_User()">Create node (55555relativeTo=User)</button>
      <button id="btnOrigin" onclick="createVisibleNode_Origin()">Create node (relativeTo=Origin)</button>
      <button id="btnList" onclick="listNodesButton()">List nodes (null props)</button>
    </div>
    <div style="margin-top:8px; font-size:12px;">
      –ï—Å–ª–∏ –Ω–æ–¥—ã —Å–æ–∑–¥–∞—é—Ç—Å—è, –Ω–æ –Ω–µ –≤–∏–¥–Ω—ã ‚Äî —á–∞—â–µ –≤—Å–µ–≥–æ –ø—Ä–æ–±–ª–µ–º–∞ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö/relativeTo/–º–∞—Å—à—Ç–∞–±–µ.
    </div>
  </div>

  <div class="box">
    <b>Log</b>
    <pre id="log" class="mono"></pre>
  </div>
</body>
</html>
