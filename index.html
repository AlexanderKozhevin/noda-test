<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Noda Smoke Test (super verbose + bridge debug)</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
    .box { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 10px 0; }
    .ok { background:#e9fbe9; }
    .bad { background:#ffe9e9; }
    .mono { font-family: ui-monospace, Menlo, Monaco, Consolas, monospace; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #999; background:#f7f7f7; cursor:pointer; margin-right: 8px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; margin: 0; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .small { font-size: 12px; opacity: 0.85; }
  </style>

  <!-- –ª–æ–∫–∞–ª—å–Ω—ã–π noda.js -->
  <script
    src="./noda.js"
    onload="window.__nodaJsLoaded=true; window.__log('‚úÖ noda.js loaded');"
    onerror="window.__nodaJsError=true; window.__log('‚ùå noda.js failed to load');"
  ></script>

  <script>
    function $(id){ return document.getElementById(id); }

    function setBox(id, ok, html) {
      const el = $(id);
      el.className = "box " + (ok ? "ok" : "bad");
      el.innerHTML = html;
    }

    function nowTs() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,"0")}`;
    }

    function __log(msg) {
      const el = $("log");
      if (!el) return;
      el.textContent = `[${nowTs()}] ${msg}\n` + el.textContent;
      el.textContent = el.textContent.slice(0, 30000);
    }
    window.__log = __log;

    function logClick(name) { __log(`üñ±Ô∏è CLICK: ${name}`); }

    function withTimeout(p, ms, label="timeout") {
      return Promise.race([
        p,
        new Promise((_, rej) => setTimeout(() => rej(new Error(label)), ms))
      ]);
    }

    function safeStringify(obj) {
      try { return JSON.stringify(obj, null, 2); } catch (e) { return String(obj); }
    }

    function summarizeVuplex() {
      const v = window.vuplex;
      if (!v) return { present:false };
      let keys = [];
      try { keys = Object.keys(v); } catch (_) {}
      return {
        present: true,
        type: typeof v,
        keys,
        hasPostMessage: typeof v.postMessage === "function",
        hasAddEventListener: typeof v.addEventListener === "function"
      };
    }

    function getNodaState() {
      const jsLoaded = !!window.__nodaJsLoaded;
      const jsError  = !!window.__nodaJsError;
      const hasNoda  = !!window.noda;

      let installed = null;
      let installedOk = false;
      if (hasNoda) {
        try {
          installed = window.noda.isInstalled();
          installedOk = (installed === true);
        } catch (e) {
          installed = "ERR: " + String(e);
        }
      }
      return { jsLoaded, jsError, hasNoda, installed, installedOk };
    }

    // ---- ACK tracking (–≤–∞–∂–Ω–æ!) ----
    let lastNodeCreatedUuid = null;
    function wireEvents() {
      if (!window.noda) return;

      window.noda.onInitialized = () => __log("EVENT onInitialized fired (from noda.js)");
      window.noda.onNodeCreated = (n) => {
        lastNodeCreatedUuid = n?.uuid ?? "(no uuid)";
        __log("EVENT onNodeCreated uuid=" + lastNodeCreatedUuid);
      };
      window.noda.onNodeUpdated = (n) => __log("EVENT onNodeUpdated uuid=" + (n?.uuid ?? "(no uuid)"));
      window.noda.onLinkCreated = (l) => __log("EVENT onLinkCreated uuid=" + (l?.uuid ?? "(no uuid)"));
    }

    // ---- Vuplex inbound logging ----
    function wireVuplexDebug() {
      // –ª–æ–≥ vuplexready
      window.addEventListener("vuplexready", () => {
        __log("üî• EVENT vuplexready fired");
        snapshot(); // –æ–±–Ω–æ–≤–∏–º –±–ª–æ–∫–∏
      });

      // –µ—Å–ª–∏ vuplex —É–∂–µ –µ—Å—Ç—å ‚Äî –ø–æ–≤–µ—Å–∏–º —Å–ª—É—à–∞—Ç–µ–ª—å ‚Äú—Å—ã—Ä–æ–≥–æ‚Äù —Å–æ–æ–±—â–µ–Ω–∏—è (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –∫ noda.js)
      if (window.vuplex && typeof window.vuplex.addEventListener === "function") {
        try {
          window.vuplex.addEventListener("message", (event) => {
            __log("‚¨ÖÔ∏è VUPLEX RAW: " + String(event.data));
            try {
              const parsed = JSON.parse(event.data);
              __log("‚¨ÖÔ∏è VUPLEX JSON: " + safeStringify(parsed));
            } catch (e) {
              __log("‚¨ÖÔ∏è VUPLEX JSON parse ERROR: " + String(e));
            }
          });
          __log("vuplex debug listener attached");
        } catch (e) {
          __log("vuplex debug listener attach ERROR: " + String(e));
        }
      } else {
        __log("vuplex not ready for debug listener yet");
      }
    }

    function snapshot() {
      const st = getNodaState();
      const vp = summarizeVuplex();

      setBox("script", !st.jsError, `
        <b>Script</b><br/>
        loaded: <span class="mono">${st.jsLoaded}</span><br/>
        error: <span class="mono">${st.jsError}</span>
      `);

      setBox("obj", st.hasNoda, `
        <b>window.noda</b><br/>
        exists: <span class="mono">${st.hasNoda}</span>
      `);

      setBox("ctx", st.installedOk, `
        <b>VR context</b><br/>
        isInstalled(): <span class="mono">${String(st.installed)}</span>
      `);

      setBox("vuplex", vp.present && vp.hasPostMessage, `
        <b>Vuplex bridge</b><br/>
        present: <span class="mono">${vp.present}</span><br/>
        type: <span class="mono">${vp.type ?? "-"}</span><br/>
        has postMessage: <span class="mono">${vp.hasPostMessage ?? false}</span><br/>
        has addEventListener: <span class="mono">${vp.hasAddEventListener ?? false}</span><br/>
        keys: <span class="mono">${(vp.keys ?? []).join(", ")}</span>
      `);

      const enabled = st.jsLoaded && st.hasNoda && st.installedOk && vp.present && vp.hasPostMessage;
      $("btnClear").disabled = !enabled;
      $("btnUser").disabled  = !enabled;
      $("btnOne").disabled   = !enabled;
      $("btnOrigin").disabled= !enabled;
      $("btnList").disabled  = !enabled;
    }

    async function safeGetUser() {
      logClick("getUser");
      try {
        __log("getUser() start‚Ä¶");
        const user = await withTimeout(window.noda.getUser(null), 12000, "getUser timeout");
        __log("getUser() result: " + safeStringify(user));
        $("userJson").textContent = safeStringify(user);
      } catch (e) {
        __log("getUser ERROR: " + String(e));
        $("userJson").textContent = "getUser ERROR: " + String(e);
      }
    }

    async function listNodesVerbose() {
      logClick("listNodes(null)");
      try {
        __log("listNodes(null) start‚Ä¶");
        const res = await withTimeout(window.noda.listNodes(null), 20000, "listNodes timeout");
        const count = (res && Array.isArray(res.nodes)) ? res.nodes.length : 0;
        __log(`listNodes OK: count=${count}`);
        $("nodesJson").textContent = safeStringify({ count, sample: res?.nodes?.slice?.(0, 3) ?? res });
      } catch (e) {
        __log("listNodes ERROR: " + String(e));
        $("nodesJson").textContent = "listNodes ERROR: " + String(e);
      }
    }

    async function clearMap() {
      logClick("clearMap");
      try {
        __log("clearMap() start‚Ä¶");
        await withTimeout(window.noda.clearMap(null), 20000, "clearMap timeout");
        __log("clearMap OK");
        setBox("status", true, `<b>Status</b><br/>Map cleared`);
      } catch (e) {
        __log("clearMap ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>clearMap ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    async function waitNodeCreatedAck(expectedUuid, ms=5000) {
      const t0 = Date.now();
      while (Date.now() - t0 < ms) {
        if (lastNodeCreatedUuid === expectedUuid) return true;
        await new Promise(r => setTimeout(r, 100));
      }
      return false;
    }

    async function createVisibleNode(relativeTo) {
      logClick("createNode (" + relativeTo + ")");
      try {
        lastNodeCreatedUuid = null;

        const uuid = "smoke:" + relativeTo.toLowerCase() + ":" + Date.now();
        const payload = {
          uuid,
          title: "VISIBLE " + relativeTo + " y=1.3 z=-2.0",
          color: "#F44336",
          opacity: 1,
          shape: "Box",
          size: 45,
          selected: true,
          notes: "Expect to see a big flashing box. If not visible, check ACK + Vuplex inbound logs.",
          location: { x: 0, y: 1.3, z: -2.0, relativeTo }
        };

        __log("createNode payload: " + safeStringify(payload));
        __log("createNode start‚Ä¶");
        const node = await withTimeout(window.noda.createNode(payload), 20000, "createNode timeout");
        __log("createNode returned: " + safeStringify(node));

        const ack = await waitNodeCreatedAck(uuid, 5000);
        __log("ACK onNodeCreated for " + uuid + ": " + ack);

        setBox("status", ack, `<b>Status</b><br/>
          createNode returned OK<br/>
          uuid: <span class="mono">${uuid}</span><br/>
          onNodeCreated ACK: <span class="mono">${ack}</span>
        `);

      } catch (e) {
        __log("createNode ERROR: " + String(e));
        setBox("status", false, `<b>Status</b><br/>createNode ERROR: <span class="mono">${String(e)}</span>`);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      __log("DOMContentLoaded");

      // –≤–∞–∂–Ω–æ: –ø–æ–≤–µ—Å–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ noda.js
      setTimeout(() => {
        try {
          wireEvents();
          wireVuplexDebug();
        } catch (e) {
          __log("wiring ERROR: " + String(e));
        }
      }, 0);

      setInterval(snapshot, 300);

      // —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å
      setTimeout(() => {
        const st = getNodaState();
        if (st.jsLoaded && st.hasNoda) {
          setBox("status", true, `<b>Status</b><br/>Ready (try getUser / createNode)`);
        } else {
          setBox("status", false, `<b>Status</b><br/>Not ready yet`);
        }
      }, 600);
    });
  </script>
</head>

<body>
  <h2>Noda Smoke Test (super verbose + bridge debug)</h2>

  <div id="script" class="box bad">‚Ä¶</div>
  <div id="obj" class="box bad">‚Ä¶</div>
  <div id="ctx" class="box bad">‚Ä¶</div>
  <div id="vuplex" class="box bad">‚Ä¶</div>

  <div id="status" class="box bad"><b>Status</b><br/>waiting‚Ä¶</div>

  <div class="box">
    <div class="row">
      <button id="btnClear"  onclick="clearMap()">Clear map</button>
      <button id="btnUser"   onclick="safeGetUser()">getUser()</button>
      <button id="btnOne"    onclick="createVisibleNode('User')">Create node777 (relativeTo=User)</button>
      <button id="btnOrigin" onclick="createVisibleNode('Origin')">Create node (relativeTo=Origin)</button>
      <button id="btnList"   onclick="listNodesVerbose()">List nodes (null props)</button>
    </div>
    <div class="small" style="margin-top:8px;">
      –ö–ª—é—á–µ–≤–æ–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä: –ø—Ä–∏—Ö–æ–¥–∏—Ç –ª–∏ <span class="mono">VUPLEX RAW</span> –∏ <span class="mono">EVENT onNodeCreated</span>.
      –ï—Å–ª–∏ <span class="mono">createNode returned OK</span>, –Ω–æ ACK=false –∏ –Ω–µ—Ç –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ‚Äî –º–æ—Å—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç.
    </div>
  </div>

  <div class="box">
    <b>User JSON:</b>
    <pre id="userJson" class="mono">‚Äî</pre>
  </div>

  <div class="box">
    <b>Nodes JSON:</b>
    <pre id="nodesJson" class="mono">‚Äî</pre>
  </div>

  <div class="box">
    <b>Log</b>
    <pre id="log" class="mono"></pre>
  </div>
</body>
</html>
